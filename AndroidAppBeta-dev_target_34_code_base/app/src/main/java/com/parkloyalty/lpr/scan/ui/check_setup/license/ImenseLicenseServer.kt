//Copyright Imense Ltd 2020. Unauthorised usage or distribution strictly prohibited.
package com.parkloyalty.lpr.scan.ui.check_setup.license

import android.os.AsyncTask
import android.util.Base64
import com.parkloyalty.lpr.scan.basecontrol.BaseApplication
import com.parkloyalty.lpr.scan.interfaces.SharedPrefKey
import com.parkloyalty.lpr.scan.interfaces.TakeLicenceInterface
import com.parkloyalty.lpr.scan.ui.continuousmode.LprContinuousScanModeActivity
import com.parkloyalty.lpr.scan.util.LogUtil.printToastMSG
import com.parkloyalty.lpr.scan.util.SharedPref
import javax.inject.Inject
import org.apache.http.auth.AuthScope
import org.apache.http.auth.UsernamePasswordCredentials
import org.apache.http.client.CredentialsProvider
import org.apache.http.client.methods.HttpGet
import org.apache.http.conn.ClientConnectionManager
import org.apache.http.conn.scheme.Scheme
import org.apache.http.conn.scheme.SchemeRegistry
import org.apache.http.conn.ssl.SSLSocketFactory
import org.apache.http.impl.client.BasicCredentialsProvider
import org.apache.http.impl.client.DefaultHttpClient
import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager
import org.apache.http.params.BasicHttpParams
import org.apache.http.params.HttpParams
import org.apache.http.util.EntityUtils
import java.io.IOException
import java.net.Socket
import java.net.UnknownHostException
import java.security.KeyStore
import javax.net.ssl.SSLContext
import javax.net.ssl.TrustManager
import javax.net.ssl.X509TrustManager
import javax.security.cert.CertificateException
import javax.security.cert.X509Certificate

//If the app does not have a valid license key generated by Imense, then this class is used to generate a unique device ID and request a new license key from
//Imense's licensing server using the SSL protocol.
class ImenseLicenseServer @Inject constructor(
    private val sharedPref: SharedPref,
    private var androidAppContext: LprScanActivity? = null,
    private var androidAppContext1: LprContinuousScanModeActivity? = null,
    private var device_uid: String? = null
) : AsyncTask<Void?, Void?, Boolean>() {
    private var licensekey: String? = null //Imense license key
    private var serverResponseMessage: String? = null //if server responds with error message
    private var TakeLicenceInterface: TakeLicenceInterface = androidAppContext ?: androidAppContext1!!

    internal inner class MySSLSocketFactory(truststore: KeyStore?) : SSLSocketFactory(truststore) {
        var sslContext = SSLContext.getInstance("TLS")

        @Throws(IOException::class, UnknownHostException::class)
        override fun createSocket(
            socket: Socket,
            host: String,
            port: Int,
            autoClose: Boolean
        ): Socket {
            return sslContext.socketFactory.createSocket(socket, host, port, autoClose)
        }

        @Throws(IOException::class)
        override fun createSocket(): Socket {
            return sslContext.socketFactory.createSocket()
        }

        init {
            val tm: TrustManager = object : X509TrustManager {
                @Throws(CertificateException::class)
                fun checkClientTrusted(chain: Array<X509Certificate?>?, authType: String?) {
                }

                @Throws(CertificateException::class)
                fun checkServerTrusted(chain: Array<X509Certificate?>?, authType: String?) {
                }

                override fun getAcceptedIssuers(): Array<java.security.cert.X509Certificate>? {
                    return null
                }

                @Throws(java.security.cert.CertificateException::class)
                override fun checkClientTrusted(
                    chain: Array<java.security.cert.X509Certificate>,
                    authType: String
                ) {
                    // TODO Auto-generated method stub
                }

                @Throws(java.security.cert.CertificateException::class)
                override fun checkServerTrusted(
                    chain: Array<java.security.cert.X509Certificate>,
                    authType: String
                ) {
                    // TODO Auto-generated method stub
                }
            }
            sslContext.init(null, arrayOf(tm), null)
        }
    }

    override fun doInBackground(vararg arg0: Void?): Boolean? {
        try {
            val uid_success = intArrayOf(0)
            //generate unique device ID
            if (device_uid == null || device_uid!!.length < VALID_UID_LENGTH) {
                throw Exception("Invalid UID")
            }
            val trustStore = KeyStore.getInstance(KeyStore.getDefaultType())
            trustStore.load(null, null)
            val sf: SSLSocketFactory = MySSLSocketFactory(trustStore)
            sf.hostnameVerifier = SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER
            val params: HttpParams = BasicHttpParams()
            val registry = SchemeRegistry()
            registry.register(Scheme("https", sf, 443))
            val ccm: ClientConnectionManager = ThreadSafeClientConnManager(params, registry)
            val client = DefaultHttpClient(ccm, params)

            //see http://hc.apache.org/httpcomponents-client/httpclient/xref/index.html
            val credsProvider: CredentialsProvider = BasicCredentialsProvider()
            credsProvider.setCredentials(
                AuthScope(AuthScope.ANY_HOST, AuthScope.ANY_PORT),
                UsernamePasswordCredentials(ImenseLicenseServerLogin, ImenseLicenseServerPassword)
            )
            client.credentialsProvider = credsProvider
            val httpget = HttpGet(ImenseLicenseServerURL + device_uid)

            // Execute the GET call and obtain the response
            val httpresponse = client.execute(httpget)
            val resEntity = httpresponse.entity

            //System.out.println("Response Status: <"+httpresponse.getStatusLine()+">");
            if (resEntity != null) {
                var resS = EntityUtils.toString(resEntity)
                resS = resS.trim()
                if (resS.length == VALID_KEY_LENGTH && !resS.startsWith("Error:")) {
                    //this should be a valid key!
                    licensekey = resS
                } else {
                    if (resS.startsWith("Error:")) {
                        serverResponseMessage = resS //human readable error message
                    }
                }
            }
            resEntity?.consumeContent()

            // When HttpClient instance is no longer needed,
            // shut down the connection manager to ensure
            // immediate deallocation of all system resources
            client.connectionManager.shutdown()
        } catch (ex: Exception) {
            //**/Log.e(tag, "error: "+ex); ex.printStackTrace();
        }
        return licensekey != null && licensekey!!.length == VALID_KEY_LENGTH //if (licensekey != null && licensekey.length()==VALID_KEY_LENGTH) {
    }

    override fun onPostExecute(result: Boolean) {
        super.onPostExecute(result)

        // Send results for single-shot mode recognition.
        if (androidAppContext != null) {
            if (licensekey != null) {
                printToastMSG(androidAppContext, "License key obtained and verified.")
                androidAppContext!!.licenseKey = licensekey
                sharedPref.write(SharedPrefKey.IS_LPR_LICENCE, true)
                sharedPref.write(SharedPrefKey.LPR_LICENCE, licensekey)
                TakeLicenceInterface.onGetLience()
            } else {
                sharedPref.write(SharedPrefKey.IS_LPR_LICENCE, false)
                printToastMSG(
                    androidAppContext,
                    "Error getting key. Please make sure WiFi Internet access is working."
                )
            }
        } else {
            if (licensekey != null) {
                printToastMSG(androidAppContext1, "License key obtained and verified.")
                androidAppContext1!!.licenseKey = licensekey
                sharedPref.write(SharedPrefKey.IS_LPR_LICENCE, true)
                TakeLicenceInterface.onGetLience()
            } else {
                sharedPref.write(SharedPrefKey.IS_LPR_LICENCE, false)
                printToastMSG(
                    androidAppContext1,
                    "Error getting key. Please make sure WiFi Internet access is working."
                )
            }
        }
    }

    companion object {
        const val LICENSESERVER_SUCCEEDED = 9999
        const val LICENSESERVER_FAILED = 7777
        private const val identity = "parkloyalty.com"

        //TODO  When update imense apk then update base64 login and password
        //	//Base64 String obfuscation
        //	private static final String ImenseLicenseServerLogin    =  decodeString("TG9naW42MTA5MTU=");
        //	private static final String ImenseLicenseServerPassword =  decodeString("b2prNjR2cm0wYzMw");
        //
        //	private static final String ImenseLicenseServerURL = decodeString("aHR0cHM6Ly9saWNlbnNpbmcuaW1lbnNlLmNvbS9rZXlnZW4yL2luZGV4LmpzcD91aWQ9");

       /* //Base64 String obfuscation
        private val ImenseLicenseServerLogin = decodeString("TG9naW42MTA5MTQ=")
        private val ImenseLicenseServerPassword = decodeString("ZmJzOXg2bHYxMW45")
        private val ImenseLicenseServerURL =
            decodeString("aHR0cHM6Ly9saWNlbnNpbmcuaW1lbnNlLmNvbS9rZXlnZW4yL2luZGV4LmpzcD91aWQ9")*/

        //Base64 String obfuscation
        private val ImenseLicenseServerLogin = decodeString("TG9naW42MTA5MTU=")
        private val ImenseLicenseServerPassword = decodeString("b2prNjR2cm0wYzMw")

        private val ImenseLicenseServerURL = decodeString("aHR0cHM6Ly9saWNlbnNpbmcuaW1lbnNlLmNvbS9rZXlnZW4yL2luZGV4LmpzcD91aWQ9")

        const val VALID_KEY_LENGTH = 32
        const val VALID_UID_LENGTH = 32
        private fun decodeString(`in`: String): String {
            val out = Base64.decode(`in`, 0)
            return String(out)
        }
    }
}